`default_nettype none

module vga_mixer(
    input wire clk,
    input wire rst,
    // GameBoy Image Input
    // Its clock need to be phase aligned, integer dividable by VGA clock
    // No clock domain crossing sync has been implemented here.
    input wire gb_hs,
    input wire gb_vs,
    input wire gb_pclk,
    input wire [1:0] gb_palette,
    input wire [1:0] gb_pdat,
    input wire gb_valid,
    // VGA signal Output
    output wire vga_hs,
    output wire vga_vs,
    output wire vga_blank,
    output reg [7:0] vga_r,
    output reg [7:0] vga_g,
    output reg [7:0] vga_b,
    
    input wire[14:0] shared_mem_a,
    input wire[1:0] shared_mem_din,
    input wire shared_mem_clk,
    input wire shared_mem_we,
    input wire shared_mem_en
    );
    localparam GB_LIGHT = 72'hCCFFCCFFCCCCCCCCFF; // Used for pixel 11
    localparam GB_MID3  = 72'h99CC99CC99999999CC;
    localparam GB_MID2  = 72'h669966996666666699;
    localparam GB_MID1  = 72'h336633663333333366;
    localparam GB_DARK  = 72'h003300330000000033; // Used for pixel 00
    localparam GB_BACK  = 24'h000000;

    //Decoded GameBoy Input colors
    wire [7:0] gb_r;
    wire [7:0] gb_g;
    wire [7:0] gb_b;

    //Background colors
    wire [7:0] bg_r;
    wire [7:0] bg_g;
    wire [7:0] bg_b;

    //X,Y positions generated by the timing generator
    wire [10:0] vga_x;
    wire [10:0] vga_y;
    
    //X,Y positions of GB display
    wire [7:0] gb_x;
    wire [7:0] gb_y;
    wire gb_grid; // If it's on grid line
    
    assign bg_r[7:0] = GB_BACK[23:16];
    assign bg_g[7:0] = GB_BACK[15:8];
    assign bg_b[7:0] = GB_BACK[7:0];
    
    //Final pixel output
    wire [7:0] out_r;
    wire [7:0] out_g;
    wire [7:0] out_b;

    wire signal_in_gb_range;
    assign out_r = (signal_in_gb_range) ? (gb_r) : (bg_r);
    assign out_g = (signal_in_gb_range) ? (gb_g) : (bg_g);
    assign out_b = (signal_in_gb_range) ? (gb_b) : (bg_b);
    
    always @(posedge clk)
    begin
        vga_r <= out_r;
        vga_g <= out_g;
        vga_b <= out_b;
    end

    // Gameboy Input
    reg last_hold;
    
    reg [14:0] gb_wr_addr;
    reg [3:0] gb_rd_palette_data;
    
    reg [14:0] gb_wr_addr_real;
    reg [14:0] gb_rd_addr_real;
    reg [1:0] gb_pdat_real;
    reg [1:0] gb_palette_real;
    wire [1:0] gb_rd_data_real;
    wire [1:0] gb_rd_palette_real;
    
    wire [1:0] shared_mem_dout;
    vga_mem_d shared_mem(
        .clk(shared_mem_clk),
        .we(shared_mem_we),
        .a(shared_mem_a),
        .d(shared_mem_din),
        
        .dpra(gb_rd_addr_real),
        .dpo(shared_mem_dout)
    );
    
    vga_mem_d vga_mem(
        .clk(clk),
        .we(1'b1),
        .a(gb_wr_addr_real),
        .d(gb_pdat_real),
        
        .dpra(gb_rd_addr_real),
        .dpo(gb_rd_data_real)
    );
    vga_mem_d palette_mem(
        .clk(clk),
        .we(1'b1),
        .a(gb_wr_addr_real),
        .d(gb_palette_real),
        
        .dpra(gb_rd_addr_real),
        .dpo(gb_rd_palette_real)
    );
    
    reg gb_vs_last;
    reg gb_hs_last;
    reg gb_pclk_last;
    
    always @(posedge clk, posedge rst)
    begin
        if (rst) begin
            gb_vs_last <= 0;
            gb_hs_last <= 0;
            gb_pclk_last <= 0;
        end
        else begin
            gb_vs_last <= gb_vs;
            gb_hs_last <= gb_hs;
            gb_pclk_last <= gb_pclk;
        end
    end

    always @(posedge clk, posedge rst)
    begin
        if (rst) begin
            gb_wr_addr <= 0;
        end
        else begin
            if ((gb_vs_last == 1)&&(gb_vs == 0)) begin
                gb_wr_addr <= 0;
            end
            else if (gb_valid) begin
                if ((gb_pclk_last == 0)&&(gb_pclk == 1)) begin
                    gb_wr_addr <= gb_wr_addr + 1'b1;
                    gb_wr_addr_real<=gb_wr_addr;
                    gb_pdat_real<=gb_pdat;
                    gb_palette_real<=gb_palette;
                end
            end
        end
    end

    wire [14:0] gb_rd_addr = gb_y * 160 + gb_x;
    
    always @ (posedge clk)
    begin
        gb_rd_palette_data[1:0] <= (shared_mem_en)?gb_rd_data_real:shared_mem_dout;
        gb_rd_palette_data[3:2] <= (shared_mem_en)?gb_rd_palette_real:2'b00;
        gb_rd_addr_real<=gb_rd_addr;
    end
    
    assign {gb_r[7:0], gb_g[7:0], gb_b[7:0]} = 
    (gb_rd_palette_data == 4'b0011) ? (GB_DARK[71:48]) : 
    (gb_rd_palette_data == 4'b0010) ? (GB_MID1[71:48]) : 
    (gb_rd_palette_data == 4'b0001) ? (GB_MID2[71:48]) :
    (gb_rd_palette_data == 4'b0000) ? (GB_MID3[71:48]) : 
    (gb_rd_palette_data == 4'b0111) ? (GB_DARK[47:24]) :
    (gb_rd_palette_data == 4'b0110) ? (GB_MID1[47:24]) : 
    (gb_rd_palette_data == 4'b0101) ? (GB_MID2[47:24]) :
    (gb_rd_palette_data == 4'b0100) ? (GB_MID3[47:24]) : 
    (gb_rd_palette_data == 4'b1011) ? (GB_DARK[23:0]) :
    (gb_rd_palette_data == 4'b1010) ? (GB_MID1[23:0]) : 
    (gb_rd_palette_data == 4'b1001) ? (GB_MID2[23:0]) :
    (gb_rd_palette_data == 4'b1000) ? (GB_MID3[23:0]) :
    (GB_BACK);
    
    vga_timing vga_timing(
      .clk(clk),
      .rst(rst),
      .hs(vga_hs),
      .vs(vga_vs),
      .vsi(1'b0),
      .x(vga_x),
      .y(vga_y),
      .gb_x(gb_x),
      .gb_y(gb_y),
      .gb_grid(gb_grid),
      .gb_en(signal_in_gb_range),
      .enable(vga_blank)
    );
    
endmodule